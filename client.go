// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.

package okms

import (
	"context"
	"crypto/tls"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/http/httputil"
	"os"
	"reflect"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/hashicorp/go-retryablehttp"
	"github.com/ovh/okms-sdk-go/internal"
	"github.com/ovh/okms-sdk-go/types"
)

const DefaultHTTPClientTimeout = 30 * time.Second

// RestAPIClient is the main client to the KMS rest api.
type RestAPIClient struct {
	inner         internal.ClientWithResponsesInterface
	customHeaders map[string]string
}

// LeveledLogger represents loggers that can be used inside the client.
type LeveledLogger retryablehttp.LeveledLogger

// ClientConfig is used to configure Rest clients created using NewRestAPIClient().
type ClientConfig struct {
	Timeout    *time.Duration
	Retry      *RetryConfig
	Logger     LeveledLogger
	TlsCfg     *tls.Config
	Middleware func(http.RoundTripper) http.RoundTripper
}

type RetryConfig struct {
	RetryMax     int
	RetryWaitMin time.Duration
	RetryWaitMax time.Duration
}

type debugTransport struct {
	next http.RoundTripper
	out  io.Writer
}

// RoundTrip implements http.RoundTripper.
func (t *debugTransport) RoundTrip(r *http.Request) (*http.Response, error) {
	data, _ := httputil.DumpRequestOut(r, true)
	fmt.Fprintf(os.Stderr, "REQUEST:\n%s\n", data)
	resp, err := t.next.RoundTrip(r)
	if err != nil {
		return resp, err
	}
	data, _ = httputil.DumpResponse(resp, true)
	fmt.Fprintf(os.Stderr, "RESPONSE:\n%s\n", data)
	return resp, nil
}

// DebugTransport creates an http client middleware that will dump all the HTTP resquests and
// responses to the giver io.Writer. It can be passed to ClientConfig.Middleware.
func DebugTransport(out io.Writer) func(http.RoundTripper) http.RoundTripper {
	return func(rt http.RoundTripper) http.RoundTripper {
		if rt == nil {
			rt = http.DefaultTransport
		}
		if out == nil {
			out = os.Stderr
		}
		return &debugTransport{
			next: rt,
			out:  out,
		}
	}
}

// NewRestAPIClient creates and initializes a new HTTP connection to the KMS at url `endpoint`
// using the provided client configuration. It allows configuring retries, timeouts and loggers.
func NewRestAPIClient(endpoint string, clientCfg ClientConfig) (*RestAPIClient, error) {
	client := retryablehttp.NewClient()
	client.HTTPClient.Timeout = DefaultHTTPClientTimeout
	client.Logger = nil

	client.HTTPClient.Transport.(*http.Transport).TLSClientConfig = clientCfg.TlsCfg
	if clientCfg.Logger != nil {
		client.Logger = clientCfg.Logger
	}

	if clientCfg.Timeout != nil {
		client.HTTPClient.Timeout = *clientCfg.Timeout
	}

	if clientCfg.Retry != nil {
		client.RetryMax = clientCfg.Retry.RetryMax
		if clientCfg.Retry.RetryWaitMin > 0 {
			client.RetryWaitMin = clientCfg.Retry.RetryWaitMin
		}
		if clientCfg.Retry.RetryWaitMax > 0 {
			client.RetryWaitMax = clientCfg.Retry.RetryWaitMax
		}
	}
	if clientCfg.Middleware != nil {
		client.HTTPClient.Transport = clientCfg.Middleware(client.HTTPClient.Transport)
	}

	client.ErrorHandler = retryablehttp.PassthroughErrorHandler

	return NewRestAPIClientWithHttp(endpoint, client.StandardClient())
}

// NewRestAPIClientWithHttp is a lower level constructor to create and initialize a new HTTP
// connection to the KMS at url `endpoint` using the provided [http.Client].
//
// The client must be configured with an appropriate tls.Config using client TLS certificates for authentication.
func NewRestAPIClientWithHttp(endpoint string, c *http.Client) (*RestAPIClient, error) {
	restClient := &RestAPIClient{}
	baseUrl := strings.TrimRight(endpoint, "/")
	client, err := internal.NewClientWithResponses(baseUrl, internal.WithHTTPClient(c), internal.WithRequestEditorFn(restClient.addRequestHeaders))

	if err != nil {
		return nil, fmt.Errorf("Failed to initialize KMS REST client: %w", err)
	}
	restClient.inner = client
	return restClient, nil
}

// InternalHttpClient is the low level, internal http client generated by oapi-codegen.
// It may be used as an escape hatch to some low level features. Use at your own risk.
type InternalHttpClient = internal.Client

// GetInternalClient returns the internal client wrapped.
// It is an escape hatch to some low level features. Use at your own risk.
func (client *RestAPIClient) GetInternalClient() *InternalHttpClient {
	c := client.inner.(*internal.ClientWithResponses)
	return c.ClientInterface.(*internal.Client)
}

// WithCustomHeader adds additional HTTP headers that will be sent with every outgoing requests.
func (client *RestAPIClient) WithCustomHeader(key, value string) *RestAPIClient {
	if client.customHeaders == nil {
		client.customHeaders = make(map[string]string)
	}
	client.customHeaders[key] = value
	return client
}

func (client *RestAPIClient) addRequestHeaders(ctx context.Context, req *http.Request) error {
	for k, v := range client.customHeaders {
		req.Header.Set(k, v)
	}
	if ctxHdrs := getContextHeaders(ctx); ctxHdrs != nil {
		for k, v := range ctxHdrs {
			req.Header.Set(k, v)
		}
	}
	return nil
}

// func (client *RestAPIClient) Ping(ctx context.Context) error {
// 	_, err := client.GenerateRandomBytes(ctx, 1)
// 	return err
// }

// func (client *RestAPIClient) GenerateRandomBytes(ctx context.Context, length int) (*types.GetRandomResponse, error) {
// 	l := int32(length)
// 	r, err := mapRestErr(client.inner.GenerateRandomBytesWithResponse(ctx, &types.GenerateRandomBytesParams{Length: &l}))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return r.JSON200, err
// }

// GetServiceKey returns a key metadata. If format is not nil, then the public key material is also returned.
func (client *RestAPIClient) GetServiceKey(ctx context.Context, keyId uuid.UUID, format *types.KeyFormats) (*types.GetServiceKeyResponse, error) {
	params := &types.GetServiceKeyParams{Format: format}
	r, err := mapRestErr(client.inner.GetServiceKeyWithResponse(ctx, keyId, params))
	if err != nil {
		return nil, err
	}
	return r.JSON200, err
}

// ListServiceKeys returns a page of service keys. The response contains a continuationToken that must be passed to the
// subsequent calls in order to get the next page. The state parameter when no nil is used to query keys having a specific state.
func (client *RestAPIClient) ListServiceKeys(ctx context.Context, continuationToken *string, maxKeys *int32, state *types.KeyStates) (*types.ListServiceKeysResponse, error) {
	params := &types.ListServiceKeysParams{ContinuationToken: continuationToken, Max: maxKeys, State: state}
	r, err := mapRestErr(client.inner.ListServiceKeysWithResponse(ctx, params))
	if err != nil {
		return nil, err
	}
	return r.JSON200, err
}

// ListAllServiceKeys returns an iterator to go through all the keys without having to deal with pagination.
func (client *RestAPIClient) ListAllServiceKeys(pageSize *int32, state *types.KeyStates) KeyIter {
	return KeyIter{
		client:   client,
		pageSize: pageSize,
		buf:      nil,
		state:    state,
	}
}

// ActivateServiceKey activates or re-activates a service key.
func (client *RestAPIClient) ActivateServiceKey(ctx context.Context, keyId uuid.UUID) error {
	_, err := mapRestErr(client.inner.ActivateServiceKeyWithResponse(ctx, keyId))
	return err
}

// UpdateServiceKey updates some service key metadata.
func (client *RestAPIClient) UpdateServiceKey(ctx context.Context, keyId uuid.UUID, body types.PatchServiceKeyRequest) (*types.GetServiceKeyResponse, error) {
	r, err := mapRestErr(client.inner.PatchServiceKeyWithResponse(ctx, keyId, body))
	if err != nil {
		return nil, err
	}
	return r.JSON200, err
}

// CreateImportServiceKey is used to either generate a new key securely in the KMS, or to import a plain key into the KMS domain.
func (client *RestAPIClient) CreateImportServiceKey(ctx context.Context, format *types.KeyFormats, body types.CreateImportServiceKeyRequest) (*types.GetServiceKeyResponse, error) {
	r, err := mapRestErr(client.inner.CreateImportServiceKeyWithResponse(ctx, &types.CreateImportServiceKeyParams{Format: format}, body))
	if err != nil {
		return nil, err
	}
	return r.JSON201, err
}

// DeactivateServiceKey deactivates a service key with the given deactivation reason.
func (client *RestAPIClient) DeactivateServiceKey(ctx context.Context, keyId uuid.UUID, reason types.RevocationReasons) error {
	_, err := mapRestErr(client.inner.DeactivateServiceKeyWithResponse(ctx, keyId, types.DeactivateServicekeyRequest{Reason: reason}))
	return err
}

// DeleteServiceKey deletes a deactivated service key. The key cannot be recovered after deletion.
// It will fail if the key is not deactivated.
func (client *RestAPIClient) DeleteServiceKey(ctx context.Context, keyId uuid.UUID) error {
	_, err := mapRestErr(client.inner.DeleteServiceKeyWithResponse(ctx, keyId))
	return err
}

// DecryptDataKey decrypts a JWE encrypted data key protected by the service key with the ID `keyId`.
func (client *RestAPIClient) DecryptDataKey(ctx context.Context, keyId uuid.UUID, encryptedKey string) ([]byte, error) {
	r, err := mapRestErr(client.inner.DecryptDataKeyWithResponse(ctx, keyId, types.DecryptDataKeyRequest{Key: encryptedKey}))
	if err != nil {
		return nil, err
	}
	if len(r.JSON200.Plaintext) == 0 {
		return nil, errors.New("Server returned no key")
	}
	return r.JSON200.Plaintext, nil
}

// GenerateDataKey creates a new data key of the given size, protected by the service key with the ID `keyId`.
// It returns the plain datakey, and the JWE encrypted version of it, which can be decrypted by calling the DecryptDataKey method.
func (client *RestAPIClient) GenerateDataKey(ctx context.Context, keyId uuid.UUID, name string, size int32) (plain []byte, encrypted string, err error) {
	req := types.GenerateDataKeyRequest{Size: size}
	if name != "" {
		req.Name = &name
	}
	r, err := mapRestErr(client.inner.GenerateDataKeyWithResponse(ctx, keyId, req))
	if err != nil {
		return nil, "", err
	}
	if r.JSON201.Plaintext == nil || len(*r.JSON201.Plaintext) == 0 {
		return nil, "", errors.New("Server returned no key")
	}
	return *r.JSON201.Plaintext, r.JSON201.Key, nil
}

// Decrypt decrypts JWE `data` previously encrypted with the remote symmetric key having the ID `keyId`.
func (client *RestAPIClient) Decrypt(ctx context.Context, keyId uuid.UUID, keyCtx, data string) ([]byte, error) {
	req := types.DecryptRequest{Ciphertext: data}
	if keyCtx != "" {
		req.Context = &keyCtx
	}
	r, err := mapRestErr(client.inner.DecryptWithResponse(ctx, keyId, req))
	if err != nil {
		return nil, err
	}
	return r.JSON200.Plaintext, nil
}

// Encrypt encrypts `data` with the remote symmetric key having the ID `keyId`. Returns a JWE (Json Web Encryption) string.
func (client *RestAPIClient) Encrypt(ctx context.Context, keyId uuid.UUID, keyCtx string, data []byte) (string, error) {
	req := types.EncryptRequest{Plaintext: data}
	if keyCtx != "" {
		req.Context = &keyCtx
	}
	r, err := mapRestErr(client.inner.EncryptWithResponse(ctx, keyId, req))
	if err != nil {
		return "", err
	}
	return r.JSON200.Ciphertext, nil
}

// Sign signs the given message with the remote private key having the ID `keyId`. The message can be pre-hashed or not.
func (client *RestAPIClient) Sign(ctx context.Context, keyId uuid.UUID, alg types.DigitalSignatureAlgorithms, preHashed bool, msg []byte) (string, error) {
	req := types.SignRequest{
		Alg:      alg,
		Isdigest: &preHashed,
		Message:  msg,
	}
	r, err := mapRestErr(client.inner.SignWithResponse(ctx, keyId, req))
	if err != nil {
		return "", err
	}
	if r.JSON200.Signature == "" {
		return "", errors.New("Server returned no signature")
	}
	return r.JSON200.Signature, err
}

// Verify checks the signature of given message against the remote public key having the ID `keyId`. The message can be pre-hashed or not.
func (client *RestAPIClient) Verify(ctx context.Context, keyId uuid.UUID, alg types.DigitalSignatureAlgorithms, preHashed bool, msg []byte, sig string) (bool, error) {
	req := types.VerifyRequest{
		Alg:       alg,
		Isdigest:  &preHashed,
		Message:   msg,
		Signature: sig,
	}
	r, err := mapRestErr(client.inner.VerifyWithResponse(ctx, keyId, req))
	if err != nil {
		return false, err
	}
	return r.JSON200.Result, nil
}

// func (client *RestAPIClient) DeleteSecretMetadata(ctx context.Context, path string) error {
// 	_, err := mapRestErr(client.inner.DeleteSecretMetadataWithResponse(ctx, path))
// 	return err
// }

// func (client *RestAPIClient) DeleteSecretRequest(ctx context.Context, path string) error {
// 	_, err := mapRestErr(client.inner.DeleteSecretRequestWithResponse(ctx, path))
// 	return err
// }

// func (client *RestAPIClient) DeleteSecretVersions(ctx context.Context, path string, versions []int32) error {
// 	_, err := mapRestErr(client.inner.DeleteSecretVersionsWithResponse(ctx, path, types.SecretVersionsRequest{Versions: versions}))
// 	return err
// }

// func (client *RestAPIClient) GetSecretConfig(ctx context.Context) (*types.GetConfigResponse, error) {
// 	r, err := mapRestErr(client.inner.GetSecretConfigWithResponse(ctx))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return r.JSON200, err
// }

// func (client *RestAPIClient) GetSecretRequest(ctx context.Context, path string, version *int32) (*types.GetSecretResponse, error) {
// 	r, err := mapRestErr(client.inner.GetSecretRequestWithResponse(ctx, path, &types.GetSecretRequestParams{Version: version}))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return r.JSON200, err
// }

// func (client *RestAPIClient) GetSecretSubkeys(ctx context.Context, path string, depth, version *int32) (*types.GetSecretSubkeysResponse, error) {
// 	r, err := mapRestErr(client.inner.GetSecretSubkeysWithResponse(ctx, path, &types.GetSecretSubkeysParams{Depth: depth, Version: version}))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return r.JSON200, err
// }

// func (client *RestAPIClient) GetSecretsMetadata(ctx context.Context, path string, list bool) (*types.GetMetadataResponse, error) {
// 	r, err := mapRestErr(client.inner.GetSecretsMetadataWithResponse(ctx, path, &types.GetSecretsMetadataParams{List: &list}))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return r.JSON200, err
// }

// func (client *RestAPIClient) PatchSecretMetadata(ctx context.Context, path string, body types.SecretUpdatableMetadata) error {
// 	_, err := mapRestErr(client.inner.PatchSecretMetadataWithResponse(ctx, path, body))
// 	return err
// }

// func (client *RestAPIClient) PatchSecretRequest(ctx context.Context, path string, body types.PostSecretRequest) (*types.PatchSecretResponse, error) {
// 	r, err := mapRestErr(client.inner.PatchSecretRequestWithResponse(ctx, path, body))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return r.JSON200, err
// }

// func (client *RestAPIClient) PostSecretConfig(ctx context.Context, body types.PostConfigRequest) error {
// 	_, err := mapRestErr(client.inner.PostSecretConfigWithResponse(ctx, body))
// 	return err
// }

// func (client *RestAPIClient) PostSecretDestroy(ctx context.Context, path string, versions []int32) error {
// 	_, err := mapRestErr(client.inner.PostSecretDestroyWithResponse(ctx, path, types.SecretVersionsRequest{Versions: versions}))
// 	return err
// }

// func (client *RestAPIClient) PostSecretMetadata(ctx context.Context, path string, body types.SecretUpdatableMetadata) error {
// 	_, err := mapRestErr(client.inner.PostSecretMetadataWithResponse(ctx, path, body))
// 	return err
// }

// func (client *RestAPIClient) PostSecretRequest(ctx context.Context, path string, body types.PostSecretRequest) (*types.PostSecretResponse, error) {
// 	r, err := mapRestErr(client.inner.PostSecretRequestWithResponse(ctx, path, body))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return r.JSON200, err
// }

// func (client *RestAPIClient) PostSecretUndelete(ctx context.Context, path string, versions []int32) error {
// 	_, err := mapRestErr(client.inner.PostSecretUndeleteWithResponse(ctx, path, types.SecretVersionsRequest{Versions: versions}))
// 	return err
// }

func mapRestErr[T interface{ StatusCode() int }](resp T, err error) (T, error) {
	if err != nil {
		return resp, err
	}
	statusCode := resp.StatusCode()
	if statusCode >= 400 { // Everything below 400 is not an error
		// Use reflection to pick the errors from the HTTP response
		rresp := reflect.Indirect(reflect.ValueOf(resp))
		httpErr := httpError{code: statusCode, cause: nil}

		body := rresp.FieldByName("Body")
		if body.IsValid() && !body.IsNil() {
			httpErr.cause = NewKmsErrorFromBytes(body.Interface().([]byte))
		}
		return resp, httpErr
	}
	return resp, nil
}

type httpError struct {
	code  int
	cause error
}

func (err httpError) Error() string {
	return fmt.Sprintf("HTTP request failed - HTTP Status: %d, %s\n%s", err.code, http.StatusText(err.code), err.cause)
}

func (err httpError) Unwrap() error {
	return err.cause
}

// ErrStatusCode returns the status code of the HTTP response that caused this error, if any.
// If err is nil, or if it was not caused by an http response (for example if it was in fact
// caused by a connectivity issue), then it returns 0.
//
// The returned status code will be 0, or a value >= 400.
func ErrStatusCode(err error) int {
	if err != nil {
		var e httpError
		if errors.As(err, &e) {
			return e.code
		}
	}
	return 0
}
