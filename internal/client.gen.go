// Package internal provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package internal

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	. "github.com/ovh/okms-sdk-go/types"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListServiceKeys request
	ListServiceKeys(ctx context.Context, params *ListServiceKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImportServiceKeyWithBody request with any body
	CreateImportServiceKeyWithBody(ctx context.Context, params *CreateImportServiceKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImportServiceKey(ctx context.Context, params *CreateImportServiceKeyParams, body CreateImportServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceKey request
	DeleteServiceKey(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceKey request
	GetServiceKey(ctx context.Context, id openapi_types.UUID, params *GetServiceKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchServiceKeyWithBody request with any body
	PatchServiceKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchServiceKeyWithApplicationWildcardPlusJSONBody(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchServiceKey(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateServiceKey request
	ActivateServiceKey(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateDataKeyWithBody request with any body
	GenerateDataKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateDataKey(ctx context.Context, id openapi_types.UUID, body GenerateDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DecryptDataKeyWithBody request with any body
	DecryptDataKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DecryptDataKey(ctx context.Context, id openapi_types.UUID, body DecryptDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateServiceKeyWithBody request with any body
	DeactivateServiceKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeactivateServiceKey(ctx context.Context, id openapi_types.UUID, body DeactivateServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DecryptWithBody request with any body
	DecryptWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Decrypt(ctx context.Context, id openapi_types.UUID, body DecryptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EncryptWithBody request with any body
	EncryptWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Encrypt(ctx context.Context, id openapi_types.UUID, body EncryptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignWithBody request with any body
	SignWithBody(ctx context.Context, id openapi_types.UUID, params *SignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Sign(ctx context.Context, id openapi_types.UUID, params *SignParams, body SignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyWithBody request with any body
	VerifyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Verify(ctx context.Context, id openapi_types.UUID, body VerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListServiceKeys(ctx context.Context, params *ListServiceKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImportServiceKeyWithBody(ctx context.Context, params *CreateImportServiceKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImportServiceKeyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImportServiceKey(ctx context.Context, params *CreateImportServiceKeyParams, body CreateImportServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImportServiceKeyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceKey(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceKey(ctx context.Context, id openapi_types.UUID, params *GetServiceKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceKeyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchServiceKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchServiceKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchServiceKeyWithApplicationWildcardPlusJSONBody(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchServiceKeyRequestWithApplicationWildcardPlusJSONBody(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchServiceKey(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchServiceKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateServiceKey(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateServiceKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateDataKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateDataKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateDataKey(ctx context.Context, id openapi_types.UUID, body GenerateDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateDataKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecryptDataKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptDataKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecryptDataKey(ctx context.Context, id openapi_types.UUID, body DecryptDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptDataKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateServiceKeyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateServiceKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateServiceKey(ctx context.Context, id openapi_types.UUID, body DeactivateServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateServiceKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DecryptWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Decrypt(ctx context.Context, id openapi_types.UUID, body DecryptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDecryptRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EncryptWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Encrypt(ctx context.Context, id openapi_types.UUID, body EncryptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEncryptRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignWithBody(ctx context.Context, id openapi_types.UUID, params *SignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sign(ctx context.Context, id openapi_types.UUID, params *SignParams, body SignJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Verify(ctx context.Context, id openapi_types.UUID, body VerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListServiceKeysRequest generates requests for ListServiceKeys
func NewListServiceKeysRequest(server string, params *ListServiceKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation-token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Max != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max", runtime.ParamLocationQuery, *params.Max); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImportServiceKeyRequest calls the generic CreateImportServiceKey builder with application/json body
func NewCreateImportServiceKeyRequest(server string, params *CreateImportServiceKeyParams, body CreateImportServiceKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImportServiceKeyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateImportServiceKeyRequestWithBody generates requests for CreateImportServiceKey with any type of body
func NewCreateImportServiceKeyRequestWithBody(server string, params *CreateImportServiceKeyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceKeyRequest generates requests for DeleteServiceKey
func NewDeleteServiceKeyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceKeyRequest generates requests for GetServiceKey
func NewGetServiceKeyRequest(server string, id openapi_types.UUID, params *GetServiceKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchServiceKeyRequestWithApplicationWildcardPlusJSONBody calls the generic PatchServiceKey builder with application/*+json body
func NewPatchServiceKeyRequestWithApplicationWildcardPlusJSONBody(server string, id openapi_types.UUID, body PatchServiceKeyApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchServiceKeyRequestWithBody(server, id, "application/*+json", bodyReader)
}

// NewPatchServiceKeyRequest calls the generic PatchServiceKey builder with application/json body
func NewPatchServiceKeyRequest(server string, id openapi_types.UUID, body PatchServiceKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchServiceKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchServiceKeyRequestWithBody generates requests for PatchServiceKey with any type of body
func NewPatchServiceKeyRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivateServiceKeyRequest generates requests for ActivateServiceKey
func NewActivateServiceKeyRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/activate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateDataKeyRequest calls the generic GenerateDataKey builder with application/json body
func NewGenerateDataKeyRequest(server string, id openapi_types.UUID, body GenerateDataKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateDataKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGenerateDataKeyRequestWithBody generates requests for GenerateDataKey with any type of body
func NewGenerateDataKeyRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/datakey", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDecryptDataKeyRequest calls the generic DecryptDataKey builder with application/json body
func NewDecryptDataKeyRequest(server string, id openapi_types.UUID, body DecryptDataKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDecryptDataKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDecryptDataKeyRequestWithBody generates requests for DecryptDataKey with any type of body
func NewDecryptDataKeyRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/datakey/decrypt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeactivateServiceKeyRequest calls the generic DeactivateServiceKey builder with application/json body
func NewDeactivateServiceKeyRequest(server string, id openapi_types.UUID, body DeactivateServiceKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeactivateServiceKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeactivateServiceKeyRequestWithBody generates requests for DeactivateServiceKey with any type of body
func NewDeactivateServiceKeyRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/deactivate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDecryptRequest calls the generic Decrypt builder with application/json body
func NewDecryptRequest(server string, id openapi_types.UUID, body DecryptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDecryptRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDecryptRequestWithBody generates requests for Decrypt with any type of body
func NewDecryptRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/decrypt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEncryptRequest calls the generic Encrypt builder with application/json body
func NewEncryptRequest(server string, id openapi_types.UUID, body EncryptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEncryptRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEncryptRequestWithBody generates requests for Encrypt with any type of body
func NewEncryptRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/encrypt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSignRequest calls the generic Sign builder with application/json body
func NewSignRequest(server string, id openapi_types.UUID, params *SignParams, body SignJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewSignRequestWithBody generates requests for Sign with any type of body
func NewSignRequestWithBody(server string, id openapi_types.UUID, params *SignParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/sign", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyRequest calls the generic Verify builder with application/json body
func NewVerifyRequest(server string, id openapi_types.UUID, body VerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVerifyRequestWithBody generates requests for Verify with any type of body
func NewVerifyRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/servicekey/%s/verify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListServiceKeysWithResponse request
	ListServiceKeysWithResponse(ctx context.Context, params *ListServiceKeysParams, reqEditors ...RequestEditorFn) (*ListServiceKeysHTTPResponse, error)

	// CreateImportServiceKeyWithBodyWithResponse request with any body
	CreateImportServiceKeyWithBodyWithResponse(ctx context.Context, params *CreateImportServiceKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImportServiceKeyHTTPResponse, error)

	CreateImportServiceKeyWithResponse(ctx context.Context, params *CreateImportServiceKeyParams, body CreateImportServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImportServiceKeyHTTPResponse, error)

	// DeleteServiceKeyWithResponse request
	DeleteServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteServiceKeyHTTPResponse, error)

	// GetServiceKeyWithResponse request
	GetServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, params *GetServiceKeyParams, reqEditors ...RequestEditorFn) (*GetServiceKeyHTTPResponse, error)

	// PatchServiceKeyWithBodyWithResponse request with any body
	PatchServiceKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchServiceKeyHTTPResponse, error)

	PatchServiceKeyWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchServiceKeyHTTPResponse, error)

	PatchServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchServiceKeyHTTPResponse, error)

	// ActivateServiceKeyWithResponse request
	ActivateServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ActivateServiceKeyHTTPResponse, error)

	// GenerateDataKeyWithBodyWithResponse request with any body
	GenerateDataKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateDataKeyHTTPResponse, error)

	GenerateDataKeyWithResponse(ctx context.Context, id openapi_types.UUID, body GenerateDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateDataKeyHTTPResponse, error)

	// DecryptDataKeyWithBodyWithResponse request with any body
	DecryptDataKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptDataKeyHTTPResponse, error)

	DecryptDataKeyWithResponse(ctx context.Context, id openapi_types.UUID, body DecryptDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*DecryptDataKeyHTTPResponse, error)

	// DeactivateServiceKeyWithBodyWithResponse request with any body
	DeactivateServiceKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeactivateServiceKeyHTTPResponse, error)

	DeactivateServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, body DeactivateServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeactivateServiceKeyHTTPResponse, error)

	// DecryptWithBodyWithResponse request with any body
	DecryptWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptHTTPResponse, error)

	DecryptWithResponse(ctx context.Context, id openapi_types.UUID, body DecryptJSONRequestBody, reqEditors ...RequestEditorFn) (*DecryptHTTPResponse, error)

	// EncryptWithBodyWithResponse request with any body
	EncryptWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptHTTPResponse, error)

	EncryptWithResponse(ctx context.Context, id openapi_types.UUID, body EncryptJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptHTTPResponse, error)

	// SignWithBodyWithResponse request with any body
	SignWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *SignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignHTTPResponse, error)

	SignWithResponse(ctx context.Context, id openapi_types.UUID, params *SignParams, body SignJSONRequestBody, reqEditors ...RequestEditorFn) (*SignHTTPResponse, error)

	// VerifyWithBodyWithResponse request with any body
	VerifyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyHTTPResponse, error)

	VerifyWithResponse(ctx context.Context, id openapi_types.UUID, body VerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyHTTPResponse, error)
}

type ListServiceKeysHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListServiceKeysResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListServiceKeysHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceKeysHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImportServiceKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GetServiceKeyResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateImportServiceKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImportServiceKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusCodes
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteServiceKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceKeyResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchServiceKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceKeyResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PatchServiceKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchServiceKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateServiceKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusCodes
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActivateServiceKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateServiceKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateDataKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GenerateDataKeyResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GenerateDataKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateDataKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DecryptDataKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DecryptDataKeyResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DecryptDataKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DecryptDataKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateServiceKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusCodes
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeactivateServiceKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateServiceKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DecryptHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DecryptResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DecryptHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DecryptHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EncryptHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncryptResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EncryptHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EncryptHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SignResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SignHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r VerifyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListServiceKeysWithResponse request returning *ListServiceKeysHTTPResponse
func (c *ClientWithResponses) ListServiceKeysWithResponse(ctx context.Context, params *ListServiceKeysParams, reqEditors ...RequestEditorFn) (*ListServiceKeysHTTPResponse, error) {
	rsp, err := c.ListServiceKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceKeysHTTPResponse(rsp)
}

// CreateImportServiceKeyWithBodyWithResponse request with arbitrary body returning *CreateImportServiceKeyHTTPResponse
func (c *ClientWithResponses) CreateImportServiceKeyWithBodyWithResponse(ctx context.Context, params *CreateImportServiceKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImportServiceKeyHTTPResponse, error) {
	rsp, err := c.CreateImportServiceKeyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImportServiceKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreateImportServiceKeyWithResponse(ctx context.Context, params *CreateImportServiceKeyParams, body CreateImportServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImportServiceKeyHTTPResponse, error) {
	rsp, err := c.CreateImportServiceKey(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImportServiceKeyHTTPResponse(rsp)
}

// DeleteServiceKeyWithResponse request returning *DeleteServiceKeyHTTPResponse
func (c *ClientWithResponses) DeleteServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteServiceKeyHTTPResponse, error) {
	rsp, err := c.DeleteServiceKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceKeyHTTPResponse(rsp)
}

// GetServiceKeyWithResponse request returning *GetServiceKeyHTTPResponse
func (c *ClientWithResponses) GetServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, params *GetServiceKeyParams, reqEditors ...RequestEditorFn) (*GetServiceKeyHTTPResponse, error) {
	rsp, err := c.GetServiceKey(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceKeyHTTPResponse(rsp)
}

// PatchServiceKeyWithBodyWithResponse request with arbitrary body returning *PatchServiceKeyHTTPResponse
func (c *ClientWithResponses) PatchServiceKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchServiceKeyHTTPResponse, error) {
	rsp, err := c.PatchServiceKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchServiceKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) PatchServiceKeyWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchServiceKeyHTTPResponse, error) {
	rsp, err := c.PatchServiceKeyWithApplicationWildcardPlusJSONBody(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchServiceKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) PatchServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, body PatchServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchServiceKeyHTTPResponse, error) {
	rsp, err := c.PatchServiceKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchServiceKeyHTTPResponse(rsp)
}

// ActivateServiceKeyWithResponse request returning *ActivateServiceKeyHTTPResponse
func (c *ClientWithResponses) ActivateServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ActivateServiceKeyHTTPResponse, error) {
	rsp, err := c.ActivateServiceKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateServiceKeyHTTPResponse(rsp)
}

// GenerateDataKeyWithBodyWithResponse request with arbitrary body returning *GenerateDataKeyHTTPResponse
func (c *ClientWithResponses) GenerateDataKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateDataKeyHTTPResponse, error) {
	rsp, err := c.GenerateDataKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateDataKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) GenerateDataKeyWithResponse(ctx context.Context, id openapi_types.UUID, body GenerateDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateDataKeyHTTPResponse, error) {
	rsp, err := c.GenerateDataKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateDataKeyHTTPResponse(rsp)
}

// DecryptDataKeyWithBodyWithResponse request with arbitrary body returning *DecryptDataKeyHTTPResponse
func (c *ClientWithResponses) DecryptDataKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptDataKeyHTTPResponse, error) {
	rsp, err := c.DecryptDataKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptDataKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) DecryptDataKeyWithResponse(ctx context.Context, id openapi_types.UUID, body DecryptDataKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*DecryptDataKeyHTTPResponse, error) {
	rsp, err := c.DecryptDataKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptDataKeyHTTPResponse(rsp)
}

// DeactivateServiceKeyWithBodyWithResponse request with arbitrary body returning *DeactivateServiceKeyHTTPResponse
func (c *ClientWithResponses) DeactivateServiceKeyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeactivateServiceKeyHTTPResponse, error) {
	rsp, err := c.DeactivateServiceKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateServiceKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) DeactivateServiceKeyWithResponse(ctx context.Context, id openapi_types.UUID, body DeactivateServiceKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeactivateServiceKeyHTTPResponse, error) {
	rsp, err := c.DeactivateServiceKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateServiceKeyHTTPResponse(rsp)
}

// DecryptWithBodyWithResponse request with arbitrary body returning *DecryptHTTPResponse
func (c *ClientWithResponses) DecryptWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DecryptHTTPResponse, error) {
	rsp, err := c.DecryptWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptHTTPResponse(rsp)
}

func (c *ClientWithResponses) DecryptWithResponse(ctx context.Context, id openapi_types.UUID, body DecryptJSONRequestBody, reqEditors ...RequestEditorFn) (*DecryptHTTPResponse, error) {
	rsp, err := c.Decrypt(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDecryptHTTPResponse(rsp)
}

// EncryptWithBodyWithResponse request with arbitrary body returning *EncryptHTTPResponse
func (c *ClientWithResponses) EncryptWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EncryptHTTPResponse, error) {
	rsp, err := c.EncryptWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptHTTPResponse(rsp)
}

func (c *ClientWithResponses) EncryptWithResponse(ctx context.Context, id openapi_types.UUID, body EncryptJSONRequestBody, reqEditors ...RequestEditorFn) (*EncryptHTTPResponse, error) {
	rsp, err := c.Encrypt(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEncryptHTTPResponse(rsp)
}

// SignWithBodyWithResponse request with arbitrary body returning *SignHTTPResponse
func (c *ClientWithResponses) SignWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *SignParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignHTTPResponse, error) {
	rsp, err := c.SignWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignHTTPResponse(rsp)
}

func (c *ClientWithResponses) SignWithResponse(ctx context.Context, id openapi_types.UUID, params *SignParams, body SignJSONRequestBody, reqEditors ...RequestEditorFn) (*SignHTTPResponse, error) {
	rsp, err := c.Sign(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignHTTPResponse(rsp)
}

// VerifyWithBodyWithResponse request with arbitrary body returning *VerifyHTTPResponse
func (c *ClientWithResponses) VerifyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyHTTPResponse, error) {
	rsp, err := c.VerifyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyHTTPResponse(rsp)
}

func (c *ClientWithResponses) VerifyWithResponse(ctx context.Context, id openapi_types.UUID, body VerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyHTTPResponse, error) {
	rsp, err := c.Verify(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyHTTPResponse(rsp)
}

// ParseListServiceKeysHTTPResponse parses an HTTP response from a ListServiceKeysWithResponse call
func ParseListServiceKeysHTTPResponse(rsp *http.Response) (*ListServiceKeysHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceKeysHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceKeysResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseCreateImportServiceKeyHTTPResponse parses an HTTP response from a CreateImportServiceKeyWithResponse call
func ParseCreateImportServiceKeyHTTPResponse(rsp *http.Response) (*CreateImportServiceKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImportServiceKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GetServiceKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDeleteServiceKeyHTTPResponse parses an HTTP response from a DeleteServiceKeyWithResponse call
func ParseDeleteServiceKeyHTTPResponse(rsp *http.Response) (*DeleteServiceKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusCodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetServiceKeyHTTPResponse parses an HTTP response from a GetServiceKeyWithResponse call
func ParseGetServiceKeyHTTPResponse(rsp *http.Response) (*GetServiceKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParsePatchServiceKeyHTTPResponse parses an HTTP response from a PatchServiceKeyWithResponse call
func ParsePatchServiceKeyHTTPResponse(rsp *http.Response) (*PatchServiceKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchServiceKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseActivateServiceKeyHTTPResponse parses an HTTP response from a ActivateServiceKeyWithResponse call
func ParseActivateServiceKeyHTTPResponse(rsp *http.Response) (*ActivateServiceKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateServiceKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusCodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGenerateDataKeyHTTPResponse parses an HTTP response from a GenerateDataKeyWithResponse call
func ParseGenerateDataKeyHTTPResponse(rsp *http.Response) (*GenerateDataKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateDataKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GenerateDataKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDecryptDataKeyHTTPResponse parses an HTTP response from a DecryptDataKeyWithResponse call
func ParseDecryptDataKeyHTTPResponse(rsp *http.Response) (*DecryptDataKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DecryptDataKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecryptDataKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDeactivateServiceKeyHTTPResponse parses an HTTP response from a DeactivateServiceKeyWithResponse call
func ParseDeactivateServiceKeyHTTPResponse(rsp *http.Response) (*DeactivateServiceKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateServiceKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusCodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDecryptHTTPResponse parses an HTTP response from a DecryptWithResponse call
func ParseDecryptHTTPResponse(rsp *http.Response) (*DecryptHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DecryptHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DecryptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseEncryptHTTPResponse parses an HTTP response from a EncryptWithResponse call
func ParseEncryptHTTPResponse(rsp *http.Response) (*EncryptHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EncryptHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncryptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseSignHTTPResponse parses an HTTP response from a SignWithResponse call
func ParseSignHTTPResponse(rsp *http.Response) (*SignHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseVerifyHTTPResponse parses an HTTP response from a VerifyWithResponse call
func ParseVerifyHTTPResponse(rsp *http.Response) (*VerifyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}
